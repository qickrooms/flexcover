Index: frameworks/projects/utilities/src/UtilitiesClasses.as
===================================================================
--- frameworks/projects/utilities/src/UtilitiesClasses.as	(revision 744)
+++ frameworks/projects/utilities/src/UtilitiesClasses.as	(working copy)
@@ -24,7 +24,9 @@
  */
 internal class UtilitiesClasses
 {
+        import coverage; coverage(null);
 	import com.adobe.viewsource.ViewSource; ViewSource;
+
 	// Maintain alphabetical order
 }
 
Index: frameworks/projects/utilities/src/coverage.as
===================================================================
--- frameworks/projects/utilities/src/coverage.as	(revision 0)
+++ frameworks/projects/utilities/src/coverage.as	(revision 0)
@@ -0,0 +1,9 @@
+package
+{
+    import com.allurent.coverage.runtime.CoverageManager;
+    
+    public function coverage(key:String):void
+    {
+        CoverageManager.recordCoverage(key);
+    }
+}
Index: frameworks/projects/utilities/src/com/allurent/coverage/runtime/CoverageManager.as
===================================================================
--- frameworks/projects/utilities/src/com/allurent/coverage/runtime/CoverageManager.as	(revision 0)
+++ frameworks/projects/utilities/src/com/allurent/coverage/runtime/CoverageManager.as	(revision 0)
@@ -0,0 +1,243 @@
+package com.allurent.coverage.runtime
+{
+    import flash.events.AsyncErrorEvent;
+    import flash.events.ErrorEvent;
+    import flash.events.SecurityErrorEvent;
+    import flash.events.StatusEvent;
+    import flash.events.TimerEvent;
+    import flash.net.LocalConnection;
+    import flash.system.fscommand;
+    import flash.utils.Timer;
+    import flash.utils.getDefinitionByName;
+    
+    /**
+     * This class provides overall coverage recording support for an instrumented application.
+     */
+    public class CoverageManager
+    {
+        public static const COVERAGE_TRACE_PREFIX:String = "__coverageData__ ";
+
+        /**
+         * LocalConnection name to be used by coverage recording.  Must be modified
+         * prior to first coverage output.
+         */
+        public static var connectionName:String = "_flexcover";
+
+        /**
+         * Time in milliseconds between flushes of coverage data to its destination.
+         * Shortening this interval increases the overall volume of data considerably.
+         */
+        public static var flushDelay:uint = 1000;
+
+        /**
+         * Flag enabling trace logging of coverage data; default value is false
+         * to avoid slowing down apps that are not connected to any data capture.
+         */
+        public static var traceEnabled:Boolean = false;
+
+        // Accumulated coverage information since the last flush.  Keys
+        // are coverage keys, and values are execution counts.
+        private static var coverageMap:Object = {};
+
+        // LocalConnection used for writing coverage data
+        private static var connection:LocalConnection;
+
+        // flag indicating attempted setup of connection
+        private static var connectionSetUp:Boolean = false;
+
+        // flag indicating that connection is known to be non-functioning,
+        // should fall back to trace logging or nothing at all.
+        private static var connectionBroken:Boolean = false;
+
+        // counter of pending writes to local connection, important
+        // in exiting the application only after all coverage data has been written
+        private static var pendingWrites:int = 0;
+
+        // "escrow" list of coverage maps that were not successfully written
+        // to the LocalConnection and may need to be written to the tracelog as a fallback.
+        private static var escrow:Array = [];
+
+        // flag indicating that a call to exit() was made.
+        private static var stopped:Boolean = false;
+        
+        // Timer instance used to drive periodic flushing of coverage data
+        private static var flushTimer:Timer = createFlushTimer(); 
+        
+        // handler function names on client end of LocalConnection
+        private static const DATA_HANDLER:String = "coverageData";
+        private static const EXIT_HANDLER:String = "coverageEnd";
+
+        // Maximum total key length allowed before forced LC send packet
+        private static const MAX_SEND_LENGTH:uint = 10000;
+        
+        /**
+         * Record the execution of a single coverage key; called by
+         * the global coverage() function.
+         */
+        public static function recordCoverage(key:String):void
+        {        
+            if (isNaN(coverageMap[key]++))
+            {
+                // The map must not have contained this key yet, so enter an
+                // execution count of 1.  Subsequent calls will autoincrement without
+                // returning NaN.
+                //
+                coverageMap[key] = 1;
+            }
+        }
+        
+        /**
+         * Flush all outstanding coverage data to the LocalConnection.
+         */
+        public static function flushCoverageData():void
+        {
+            // Attempt to initialize the local connection if not yet set up.
+            //
+            if (!connectionSetUp)
+            {
+                connection = new LocalConnection();
+                connection.addEventListener(AsyncErrorEvent.ASYNC_ERROR, handleError);
+                connection.addEventListener(SecurityErrorEvent.SECURITY_ERROR, handleError);
+                connection.addEventListener(StatusEvent.STATUS, handleStatus);
+                connectionSetUp = true;
+            }
+            try
+            {
+                // First push our coverageMap on the escrow list, since we might need
+                // to try to log it to the trace log later if this write fails.
+                escrow.push(coverageMap);
+
+                if (connectionBroken)
+                {
+                    // Our connection is known to be trashed, so trace the coverage
+                    // information or toss it as per the traceEnabled flag.
+                    //
+                    traceCoverage();
+                }
+                else
+                {
+                    // Repeatedly accumulate MAX_SEND_LENGTH worth of coverage key/value
+                    // pairs in tempMap, sending over the LocalConnection as this limit
+                    // is reached.  This is a crude attempt to avoid exceeding the data size limit
+                    // inherent in LocalConnection.
+                    //
+                    var i:uint = 0;
+                    var tempMap:Object = {};
+                    for (var key:String in coverageMap)
+                    {
+                        tempMap[key] = coverageMap[key];
+                        if ((i += key.length) > MAX_SEND_LENGTH)
+                        {
+                            connection.send(connectionName, DATA_HANDLER, tempMap);
+                            pendingWrites++;
+                            tempMap = {};
+                            i = 0;
+                        }
+                    }
+
+                    // We might have some keys left over that didn't hit the max limit.
+                    //
+                    connection.send(connectionName, DATA_HANDLER, tempMap);
+                    pendingWrites++;
+                }
+            }
+            catch (e:Error)
+            {
+                // In the case of a runtime error, blow off the connection and trace.
+                //
+                trace(e.message);
+                connectionBroken = true;
+                traceCoverage();
+            }
+
+            coverageMap = {};
+        }
+        
+        /**
+         * Request the application to exit after all pending data has been written.
+         * This call also signals a remote receiver that it can process remaining data
+         * and itself exit.
+         */
+        public static function exit():void
+        {
+            flushCoverageData();
+            if (!connectionBroken)
+            {
+                connection.send(connectionName, EXIT_HANDLER);
+                pendingWrites++;
+            }
+            stopped = true;
+            checkForExit();
+        }
+
+        private static function handleError(e:ErrorEvent):void
+        {
+            trace(e.text);
+        }
+        
+        private static function handleStatus(e:StatusEvent):void
+        {
+            if (e.level == "error")
+            {
+                // Something went awry.
+                // TODO: This may write more data to the log than was actually lost,
+                //    but the assumption for now is that the LC either works all the time or
+                //    fails all the time.
+                //
+                connectionBroken = true;
+                traceCoverage();
+            }
+            else if (e.level == "status")
+            {
+                // guess we were able to send OK
+                escrow = [];
+                pendingWrites--;
+            }
+            checkForExit();
+        }
+        
+        private static function checkForExit():void
+        {
+            if ((pendingWrites == 0 || connectionBroken) && stopped)
+            {
+                var nativeApp:Object = getDefinitionByName("flash.desktop.NativeApplication");
+                if (nativeApp != null)
+                {
+                    nativeApp.nativeApplication.exit();
+                }
+                else
+                {
+                    fscommand("quit", "");
+                }
+            }
+        }
+        
+        private static function handleFlushTimer(e:TimerEvent):void
+        {
+            flushCoverageData();
+        }
+        
+        private static function createFlushTimer():Timer
+        {
+            var t:Timer = new Timer(flushDelay, 0);
+            t.addEventListener(TimerEvent.TIMER, handleFlushTimer);
+            t.start();
+            return t;
+        }
+        
+        private static function traceCoverage():void
+        {
+            if (traceEnabled)
+            {
+                for each (var map:Object in escrow)
+                {
+                    for (var key:String in map)
+                    {
+                        trace(COVERAGE_TRACE_PREFIX + key + " " + map[key]);
+                    }
+                }
+            }
+            escrow = [];
+        }
+    }
+}
Index: development/eclipse/java/flex-jars/.classpath
===================================================================
--- development/eclipse/java/flex-jars/.classpath	(revision 744)
+++ development/eclipse/java/flex-jars/.classpath	(working copy)
@@ -1,32 +1,32 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<classpath>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xalan.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/afe.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/asc.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik_ja.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-awt-util.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-bridge.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-css.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-dom.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-ext.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-gvt.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-parser.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-script.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-svg-dom.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-svggen.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-transcoder.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-util.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-xml.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-collections.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-discovery.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-logging.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/flex-messaging-common.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/javacc.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/mm-velocity-1.4.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesImpl_ja.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesImpl.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesPatch.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xmlParserAPIs.jar"/>
-	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/aglj32.jar"/>
-	<classpathentry kind="output" path="bin"/>
-</classpath>
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xalan.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/afe.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/modules/asc/lib/asc.jar" sourcepath="/FLEX_SDK/modules/asc/src/java"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik_ja.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-awt-util.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-bridge.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-css.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-dom.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-ext.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-gvt.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-parser.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-script.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-svg-dom.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-svggen.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-transcoder.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-util.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/batik-xml.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-collections.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-discovery.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/commons-logging.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/flex-messaging-common.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/javacc.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/mm-velocity-1.4.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesImpl_ja.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesImpl.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xercesPatch.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/xmlParserAPIs.jar"/>
+	<classpathentry exported="true" kind="var" path="FLEX_SDK/lib/aglj32.jar"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>
Index: lib/asc.jar
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream
Index: modules/asc/src/java/macromedia/asc/semantics/Emitter.java
===================================================================
--- modules/asc/src/java/macromedia/asc/semantics/Emitter.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/semantics/Emitter.java	(working copy)
@@ -146,20 +146,24 @@
 
 	protected void StartMethod()
 	{
-		StartMethod("", 0, 0, 0, false, 0);
+		StartMethod("", 0, 0, 0, false, 0, null);
 	}
 
 	protected void StartMethod(final String name, int param_count, int local_count)
 	{
-		StartMethod(name, param_count, local_count, 0, false, 0);
+		StartMethod(name, param_count, local_count, 0, false, 0, null);
 	}
 
-	protected void StartMethod(final String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments)
+    protected void StartMethod(final String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments)
+    {
+        StartMethod(name, param_count, local_count, 0, false, 0, null);
+    }
+	protected void StartMethod(final String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments, final String debug_name)
 	{
 		doing_method = true;
 		if (impl != null)
 		{
-			impl.StartMethod(name, param_count, local_count, temp_count, needs_activation, needs_arguments);
+			impl.StartMethod(name, param_count, local_count, temp_count, needs_activation, needs_arguments, debug_name);
 		}
 	}
 
Index: modules/asc/src/java/macromedia/asc/semantics/CodeGenerator.java
===================================================================
--- modules/asc/src/java/macromedia/asc/semantics/CodeGenerator.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/semantics/CodeGenerator.java	(working copy)
@@ -60,6 +60,8 @@
     }
     private StackFrame frame = null;
     private ObjectList<StackFrame> frames = new ObjectList<StackFrame>();
+    
+    private ObjectList<String> coverageScopes = new ObjectList<String>();
 
     class ExceptionState
     {
@@ -3535,10 +3537,23 @@
             fexpr.evaluate(cx, this);
         }
 */
+        String coverageName = null;
+        if (!(currentClass instanceof InterfaceDefinitionNode))
+        {
+            coverageName = node.debug_name;
+            if (coverageName == null || coverageName.length() == 0)
+            {
+                coverageName = coverageScopes.last() + "_" + node.internal_name;
+            }
+        }
+        
+        coverageScopes.push_back(coverageName);
         for (FunctionCommonNode def : node.fexprs)
         {
             def.evaluate(cx, this);
         }
+        coverageScopes.pop_back();
+        
         // reset debug position.  nested Function evaulation above will have updated it, we need to reset to top of this function.
         setPosition(cx.input.getLnNum(node.pos()),cx.input.getColPos(node.pos()),node.pos());
 
@@ -3562,7 +3577,7 @@
         frame.activationIsExposed = needs_activation;
         frame.registerScopeIndex = needs_activation ? -1 : (cx.getScopes().size()-1);
 
-        StartMethod(frame.functionName,frame.maxParams,frame.maxLocals,0,needs_activation,node.needsArguments);
+        StartMethod(frame.functionName,frame.maxParams,frame.maxLocals,0,needs_activation,node.needsArguments,coverageName);
 
         // If this is a constructor, then insert a call to the base constructor,
         // and the instance initializer
@@ -3809,12 +3824,14 @@
 
         StartProgram(getProgramName(cx));
 
+        coverageScopes.push_back("");
         for (int i = (node.fexprs == null) ? -1 : node.fexprs.size() - 1; i >= 0; i--)
         {
             Node fexpr = node.fexprs.get(i);
             fexpr.evaluate(cx, this);
         }
-
+        coverageScopes.pop_back();
+        
         for (ClassDefinitionNode def : node.clsdefs)
         {
             def.evaluate(cx, this);
@@ -4257,10 +4274,12 @@
 			FinishMethod(cx,frame.functionName,type,types,null/*node->cframe*/,0,cx.getScopes().size(),"",false,false, null);
 
             {
+                coverageScopes.push_back(frame.functionName);
                 for (FunctionCommonNode expr : node.staticfexprs)
                 {
                     expr.evaluate(cx, this);
                 }
+                coverageScopes.pop_back();
             }
 
             popStackFrame();
@@ -4320,10 +4339,12 @@
          * User defined methods
          */
 
+        coverageScopes.push_back(node.cframe.builder.classname + "/" + node.cframe.builder.classname + "$iinit");
         for (ListIterator<FunctionCommonNode> it = node.fexprs.listIterator(); it.hasNext(); )
         {
             it.next().evaluate(cx,this);
         }
+        coverageScopes.pop_back();
 
         boolean is_dynamic = node.attrs != null ? node.attrs.hasDynamic : false;
         boolean is_final = node.attrs != null ? node.attrs.hasFinal : false;
Index: modules/asc/src/java/macromedia/asc/semantics/FlowGraphEmitter.java
===================================================================
--- modules/asc/src/java/macromedia/asc/semantics/FlowGraphEmitter.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/semantics/FlowGraphEmitter.java	(working copy)
@@ -468,7 +468,7 @@
 	}
 
 
-	public void StartMethod(String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments)
+	public void StartMethod(String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments, String debug_name)
 	{
 		if (show_instructions)
 		{
Index: modules/asc/src/java/macromedia/asc/util/ContextStatics.java
===================================================================
--- modules/asc/src/java/macromedia/asc/util/ContextStatics.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/util/ContextStatics.java	(working copy)
@@ -52,6 +52,7 @@
 	public CompilerHandler handler = null;
 	String pathspec;
 	String scriptname;
+	HashSet<String> coverageKeys = new HashSet<String>();
 
 	public static final int LANG_EN		= 0;
 	public static final int LANG_DE		= 1;
@@ -306,4 +307,9 @@
     	static_protected_namespaces.remove(name);
     	namespaces.remove(name);
     }
+    
+    public void addCoverageKey(String key)
+    {
+        coverageKeys.add(key);
+    }
 }
Index: modules/asc/src/java/macromedia/asc/util/Context.java
===================================================================
--- modules/asc/src/java/macromedia/asc/util/Context.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/util/Context.java	(working copy)
@@ -1525,5 +1525,12 @@
         }
         return code;
     }
+
+    public Set getCoverageKeys() {
+        return statics.coverageKeys;
+    }
     
+    public void clearCoverageKeys() {
+        statics.coverageKeys = new HashSet<String>();
+    }
 }
Index: modules/asc/src/java/macromedia/asc/embedding/avmplus/DebugInfo.java
===================================================================
--- modules/asc/src/java/macromedia/asc/embedding/avmplus/DebugInfo.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/embedding/avmplus/DebugInfo.java	(working copy)
@@ -23,5 +23,7 @@
     String debug_file;
     boolean suppress_debug_method = false;
     boolean debug_file_dirty = false;
+    String debug_function;
+    boolean debug_function_dirty = false;
 }
 
Index: modules/asc/src/java/macromedia/asc/embedding/avmplus/ActionBlockEmitter.java
===================================================================
--- modules/asc/src/java/macromedia/asc/embedding/avmplus/ActionBlockEmitter.java	(revision 744)
+++ modules/asc/src/java/macromedia/asc/embedding/avmplus/ActionBlockEmitter.java	(working copy)
@@ -776,10 +776,10 @@
 
     protected void StartMethod()
     {
-        StartMethod("", 0, 0, 0, false, 0);
+        StartMethod("", 0, 0, 0, false, 0, null);
     }
 
-    protected void StartMethod(final String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments)
+    protected void StartMethod(final String name, int param_count, int local_count, int temp_count, boolean needs_activation, int needs_arguments, String debug_name)
     {
         if (show_instructions)
         {
@@ -813,6 +813,9 @@
         debug_info.debug_linenum_dirty = true;
         debug_info.suppress_debug_method = (name.indexOf("$iinit") != -1 ||
                                             name.indexOf("$cinit") != -1);
+        debug_info.debug_function = debug_name;
+        debug_info.debug_function_dirty = true;
+        
         sets_dxns = false;
     }
 
@@ -2063,10 +2066,11 @@
     /*
      * DebugFile
      */
-    protected void DebugFile(String name)
+    protected String DebugFile(String name)
     {
         int index = ab.addUtf8Constant(bytecodeFactory.ConstantUtf8Info(name));
         DebugFile(ab.code, index);
+        return name;
     }
 
     /*
@@ -7735,18 +7739,29 @@
                 ab.code != null &&
                 !debug_info.suppress_debug_method)
             {
+                String debugFileName = null;
                 if (debug_info.debug_file_dirty)
                 {
-                    DebugFile(debug_info.debug_file);
+                    debugFileName = DebugFile(debug_info.debug_file);
                     debug_info.debug_file_dirty = false;
                 }
                 
                 DebugLine(debug_info.debug_linenum);
                 debug_info.debug_linenum_dirty = false;
+                
+                // Spit out calls to a global coverage-monitoring function
+                if (debug_info.debug_function != null && debug_info.debug_function.length() > 0)
+                {
+                    RecordCoverage(debug_info.debug_function, debug_info.debug_linenum, debugFileName);
+                }
             }
         }
     }
 
+    public void RecordCoverage(String functionName, int linenum, String debugFileName)
+    {
+    }
+
     public void reorderMainScript()
     {
         ab.scripts.add(ab.scripts.remove(0));
Index: modules/compiler/src/java/flex2/tools/flexbuilder/BuilderApplication.java
===================================================================
--- modules/compiler/src/java/flex2/tools/flexbuilder/BuilderApplication.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/flexbuilder/BuilderApplication.java	(working copy)
@@ -133,10 +133,18 @@
 							{
 							}
 						}
-						else if ("link-report".equals(var))
-						{
-							config.keepLinkReport(true);
-						}
+                        else if ("link-report".equals(var))
+                        {
+                            config.keepLinkReport(true);
+                        }
+                        else if ("coverage-report".equals(var))
+                        {
+                            config.keepCoverageMetadata(true);
+                        }
+                        else if ("compiler.coverage".equals(var))
+                        {
+                            config.enableCoverage(true);
+                        }
 						else if ("compiler.debug".equals(var))
 						{
 							try
@@ -378,7 +386,8 @@
 		excludes.add("output");
 		excludes.add("version");
 		excludes.add("warnings");
-		excludes.add("compiler.debug");
+        excludes.add("compiler.coverage");
+        excludes.add("compiler.debug");
 		excludes.add("compiler.profile");
 		excludes.add("compiler.accessible");
 		excludes.add("compiler.strict");
Index: modules/compiler/src/java/flex2/tools/flexbuilder/BuilderLibrary.java
===================================================================
--- modules/compiler/src/java/flex2/tools/flexbuilder/BuilderLibrary.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/flexbuilder/BuilderLibrary.java	(working copy)
@@ -123,10 +123,18 @@
 							{
 							}
 						}
-						else if ("link-report".equals(var))
-						{
-							config.keepLinkReport(true);
-						}
+                        else if ("link-report".equals(var))
+                        {
+                            config.keepLinkReport(true);
+                        }
+                        else if ("coverage-report".equals(var))
+                        {
+                            config.keepCoverageMetadata(true);
+                        }
+                        else if ("compiler.coverage".equals(var))
+                        {
+                            config.enableCoverage(true);
+                        }
 						else if ("compiler.debug".equals(var))
 						{
 							try
@@ -370,7 +378,8 @@
 		excludes.add("include-sources");
 		excludes.add("output");
 		excludes.add("version");
-		excludes.add("compiler.debug");
+        excludes.add("compiler.coverage");
+        excludes.add("compiler.debug");
 		excludes.add("compiler.profile");
 		excludes.add("compiler.accessible");
 		excludes.add("compiler.strict");
Index: modules/compiler/src/java/flex2/tools/flexbuilder/BuilderConfiguration.java
===================================================================
--- modules/compiler/src/java/flex2/tools/flexbuilder/BuilderConfiguration.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/flexbuilder/BuilderConfiguration.java	(working copy)
@@ -96,6 +96,11 @@
 	{
 		configuration.checkActionScriptWarning(warningCode, b);
 	}
+	
+	public void enableCoverage(boolean b)
+	{
+	    configuration.enableCoverage(b);
+	}
 
 	public void enableAccessibility(boolean b)
 	{
@@ -142,10 +147,15 @@
 		configuration.keepCompilerGeneratedActionScript(b);
 	}
 
-	public void keepLinkReport(boolean b)
-	{
-		configuration.keepLinkReport(b);
-	}
+    public void keepLinkReport(boolean b)
+    {
+        configuration.keepLinkReport(b);
+    }
+
+    public void keepCoverageMetadata(boolean b)
+    {
+        configuration.keepCoverageMetadata(b);
+    }
 
 	public void keepConfigurationReport(boolean b)
 	{
Index: modules/compiler/src/java/flex2/tools/oem/Configuration.java
===================================================================
--- modules/compiler/src/java/flex2/tools/oem/Configuration.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/oem/Configuration.java	(working copy)
@@ -118,6 +118,12 @@
     void setContextRoot(String path);
 
     /**
+     * Enable coverage in the compiler.
+     * @param b
+     */
+    void enableCoverage(boolean b);
+    
+    /**
      * Enables debugging in the application.
      * This is equivalent to using the <code>compiler.debug</code> and <code>-debug-password=true|false</code> options
      * for the mxmlc or compc compilers.
@@ -307,6 +313,14 @@
     void keepLinkReport(boolean b);
     
     /**
+     * Instructs the linker to keep a report of the coverage data that is included in the application.
+     * You can use the <code>Report.writeCoverageMetadata()</code> method to retrieve the linker report.
+     * 
+     * @param b Boolean value.
+     */
+    void keepCoverageMetadata(boolean b);
+    
+    /**
      * Instructs the compiler to keep a report of the compiler configuration settings.
      * You can use the <code>Report.writeConfigurationReport()</code> method to retrieve the configuration report.
      * 
Index: modules/compiler/src/java/flex2/tools/oem/internal/ConfigurationConstants.java
===================================================================
--- modules/compiler/src/java/flex2/tools/oem/internal/ConfigurationConstants.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/oem/internal/ConfigurationConstants.java	(working copy)
@@ -30,6 +30,7 @@
     String METADATA_DATE                                        = "--metadata.date";
     String METADATA_CREATOR                                     = "--metadata.creator";
     String METADATA_CONTRIBUTOR                                 = "--metadata.contributor";
+    String COVERAGE_METADATA                                    = "--coverage-metadata";
     String LINK_REPORT                                          = "--link-report";
     String LICENSES_LICENSE                                     = "--licenses.license";
     String INCLUDES                                             = "--includes";
@@ -108,6 +109,7 @@
     String COMPILER_EXTERNAL_LIBRARY_PATH                       = "--compiler.external-library-path";
     String COMPILER_ES                                          = "--compiler.es";
     String COMPILER_DEFAULTS_CSS_URL                            = "--compiler.defaults-css-url";
+    String COMPILER_COVERAGE                                    = "--compiler.coverage";
     String COMPILER_DEBUG                                       = "--compiler.debug";
     String COMPILER_CONTEXT_ROOT                                = "--compiler.context-root";
     String COMPILER_AS3                                         = "--compiler.as3";
Index: modules/compiler/src/java/flex2/tools/oem/internal/OEMConfiguration.java
===================================================================
--- modules/compiler/src/java/flex2/tools/oem/internal/OEMConfiguration.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/oem/internal/OEMConfiguration.java	(working copy)
@@ -93,7 +93,7 @@
 	private TreeMapAdapter args, defaults, more, linker_args, linker_more;
 	private String[] extras;
 	public final Set newLinkerOptionsAfterCompile;
-	private boolean keepLinkReport, keepConfigurationReport;
+	private boolean keepLinkReport, keepCoverageMetadata, keepConfigurationReport;
 	
 	private Map tokens;
 
@@ -537,6 +537,11 @@
 		newLinkerOptionsAfterCompile.add(COMPILER_DEBUG);
 		newLinkerOptionsAfterCompile.add(DEBUG_PASSWORD);
 	}
+	
+	public void enableCoverage(boolean b)
+	{
+	    args.put(COMPILER_COVERAGE, b ? Boolean.TRUE : Boolean.FALSE);
+	}
 
 	/**
 	 * Sets the location of the default CSS file.
@@ -742,23 +747,34 @@
 		args.put(COMPILER_KEEP_GENERATED_ACTIONSCRIPT, b ? Boolean.TRUE : Boolean.FALSE);
 	}
 
-	/**
-	 * Instructs the linker to keep a report of the content that is included in the application.
-	 * Callers may use <code>Report.writeLinkReport()</code> to retrieve the linker report.
-	 * 
-	 * @param b boolean value
-	 */
-	public void keepLinkReport(boolean b)
-	{
-		keepLinkReport = b;
-		newLinkerOptionsAfterCompile.add(LINK_REPORT);
-	}
-	
-	public boolean keepLinkReport()
-	{
-		return keepLinkReport;
-	}
-	
+    /**
+     * Instructs the linker to keep a report of the content that is included in the application.
+     * Callers may use <code>Report.writeLinkReport()</code> to retrieve the linker report.
+     * 
+     * @param b boolean value
+     */
+    public void keepLinkReport(boolean b)
+    {
+        keepLinkReport = b;
+        newLinkerOptionsAfterCompile.add(LINK_REPORT);
+    }
+    
+    public boolean keepLinkReport()
+    {
+        return keepLinkReport;
+    }
+    
+    public void keepCoverageMetadata(boolean b)
+    {
+        keepCoverageMetadata = b;
+        newLinkerOptionsAfterCompile.add(COVERAGE_METADATA);
+    }
+    
+    public boolean keepCoverageMetadata()
+    {
+        return keepCoverageMetadata;
+    }
+    
 	/**
 	 * Instructs the compiler to keep a report of the compiler configuration settings.
 	 * Callers may use <code>Report.writeConfigurationReport()</code> to retrieve the configuration report.
@@ -2170,6 +2186,7 @@
 		useActionScript3(cc.dialect() == CompilerConfiguration.AS3Dialect);
 		setContextRoot(cc.getContextRoot());
 		enableDebugging(cc.debug(), configuration.debugPassword());
+		enableCoverage(cc.coverage());
 		
 		if (cc.getDefaultsCssUrl() != null)
 		{
Index: modules/compiler/src/java/flex2/tools/oem/internal/ApplicationCompilerConfiguration.java
===================================================================
--- modules/compiler/src/java/flex2/tools/oem/internal/ApplicationCompilerConfiguration.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/oem/internal/ApplicationCompilerConfiguration.java	(working copy)
@@ -118,21 +118,37 @@
 	}
 
     //
-	// 'generate-link-report' option
-	//
-	
-	private boolean generateLinkReport;
-	
-	public boolean generateLinkReport()
-	{
-		return generateLinkReport;
-	}
-	
-	public void keepLinkReport(boolean b)
-	{
-		generateLinkReport = b;
-	}
-	
+    // 'generate-link-report' option
+    //
+    
+    private boolean generateLinkReport;
+    
+    public boolean generateLinkReport()
+    {
+        return generateLinkReport;
+    }
+    
+    public void keepLinkReport(boolean b)
+    {
+        generateLinkReport = b;
+    }
+    
+    //
+    // 'generate-coverage-report' option
+    //
+    
+    private boolean generateCoverageMetadata;
+    
+    public boolean generateCoverageMetadata()
+    {
+        return generateCoverageMetadata;
+    }
+    
+    public void keepCoverageMetadata(boolean b)
+    {
+        generateCoverageMetadata = b;
+    }
+    
 	//
 	// 'load-config' option
 	//
Index: modules/compiler/src/java/flex2/tools/PreLink.java
===================================================================
--- modules/compiler/src/java/flex2/tools/PreLink.java	(revision 744)
+++ modules/compiler/src/java/flex2/tools/PreLink.java	(working copy)
@@ -1147,6 +1147,8 @@
 		    "        }", lineSep,
 		    "    }", lineSep,
 		    codegenRslCompleteListener(configuration, lineSep),
+            configuration.getCompilerConfiguration().coverage()
+            ? "    private function coverageDependency():void { coverage(null); }" : "",
 		    "}", lineSep, lineSep,
 		    "}", lineSep,
 	    };
Index: modules/compiler/src/java/flex2/linker/Configuration.java
===================================================================
--- modules/compiler/src/java/flex2/linker/Configuration.java	(revision 744)
+++ modules/compiler/src/java/flex2/linker/Configuration.java	(working copy)
@@ -123,6 +123,12 @@
     String getLinkReportFileName();
     boolean generateLinkReport();
 
+    /**
+     * @return name of coverage report file, null if none
+     */
+    String getCoverageMetadataFileName();
+    boolean generateCoverageMetadata();
+
 	/**
 	 * @return name of resource bundle list file, null if none
 	 */
Index: modules/compiler/src/java/flex2/linker/API.java
===================================================================
--- modules/compiler/src/java/flex2/linker/API.java	(revision 744)
+++ modules/compiler/src/java/flex2/linker/API.java	(working copy)
@@ -75,6 +75,18 @@
 		        ThreadLocalToolkit.log( new LinkerException.UnableToWriteLinkReport( fileName ) );
 	    	}
 	    }
+        if (configuration.generateCoverageMetadata() && configuration.getCoverageMetadataFileName() != null)
+        {
+            String fileName = configuration.getCoverageMetadataFileName();
+            try
+            {
+                FileUtil.writeFile(fileName, movie.getCoverageMetadata());
+            }
+            catch (Exception ex)
+            {
+                ThreadLocalToolkit.log( new LinkerException.UnableToWriteLinkReport( fileName ) );
+            }
+        }
 	    if (configuration.generateRBList() && configuration.getRBListFileName() != null)
 	    {
 	    	String fileName = configuration.getRBListFileName();
Index: modules/compiler/src/java/flex2/linker/SimpleMovie.java
===================================================================
--- modules/compiler/src/java/flex2/linker/SimpleMovie.java	(revision 744)
+++ modules/compiler/src/java/flex2/linker/SimpleMovie.java	(working copy)
@@ -149,8 +149,9 @@
     protected String rootClassName;
     protected Map exportedUnits;
     
-    protected boolean generateLinkReport, generateRBList;
+    protected boolean generateLinkReport, generateCoverageMetadata, generateRBList;
     protected String linkReport;
+    protected String coverageReport;
 	protected String rbList;
 
     protected static String formatSymbolClassName( String className )
@@ -336,6 +337,11 @@
     	return linkReport;
     }
     
+    public String getCoverageMetadata()
+    {
+        return coverageReport;
+    }
+    
     public String getRBList()
     {
     	return rbList;
Index: modules/compiler/src/java/flex2/linker/CoverageMetadataWriter.java
===================================================================
--- modules/compiler/src/java/flex2/linker/CoverageMetadataWriter.java	(revision 0)
+++ modules/compiler/src/java/flex2/linker/CoverageMetadataWriter.java	(revision 0)
@@ -0,0 +1,44 @@
+////////////////////////////////////////////////////////////////////////////////
+//
+//  ADOBE SYSTEMS INCORPORATED
+//  Copyright 2005-2007 Adobe Systems Incorporated
+//  All Rights Reserved.
+//
+//  NOTICE: Adobe permits you to use, modify, and distribute this file
+//  in accordance with the terms of the license agreement accompanying it.
+//
+////////////////////////////////////////////////////////////////////////////////
+
+package flex2.linker;
+
+import java.util.*;
+
+import flex2.compiler.CompilationUnit;
+
+/**
+ * @author Joe Berkovitz
+ *
+ * Spit out a list of all the coverage keys collected during all the byte code emitted.
+ *
+ */
+public class CoverageMetadataWriter
+{
+
+    public static String dump(List units)
+    {
+        StringBuffer buf = new StringBuffer( 2048 );
+        for (Iterator it = units.iterator(); it.hasNext(); )
+        {
+            CompilationUnit unit = (CompilationUnit) it.next();
+            if (unit.coverageKeys != null)
+            {
+                for (Iterator it2 = unit.coverageKeys.iterator(); it2.hasNext(); )
+                {
+                    buf.append(it2.next().toString());
+                    buf.append('\n');
+                }
+            }
+        }
+        return buf.toString();
+    }
+}
Index: modules/compiler/src/java/flex2/linker/FlexMovie.java
===================================================================
--- modules/compiler/src/java/flex2/linker/FlexMovie.java	(revision 744)
+++ modules/compiler/src/java/flex2/linker/FlexMovie.java	(working copy)
@@ -52,6 +52,7 @@
 	    includes = new HashSet(configuration.getIncludes());
         unresolved = new HashSet(configuration.getUnresolved());
         generateLinkReport = configuration.generateLinkReport();
+        generateCoverageMetadata = configuration.generateCoverageMetadata();
         generateRBList = configuration.generateRBList();
 	    resourceBundles = new TreeSet(configuration.getResourceBundles());
 
@@ -241,6 +242,10 @@
             {
             	linkReport = DependencyWalker.dump( state );
             }
+            if (generateCoverageMetadata)
+            {
+                coverageReport = CoverageMetadataWriter.dump( units );
+            }
             if (generateRBList)
             {
             	rbList = dumpRBList(resourceBundles);
Index: modules/compiler/src/java/flex2/configuration_en.properties
===================================================================
--- modules/compiler/src/java/flex2/configuration_en.properties	(revision 744)
+++ modules/compiler/src/java/flex2/configuration_en.properties	(working copy)
@@ -187,6 +187,7 @@
 Brief=${program} [options] [defaultVar]\nUse '${program} -help' for more information.\n\n
 
 compiler.allow-source-path-overlap=checks if a source-path entry is a subdirectory of another source-path entry. It helps make the package names of MXML components unambiguous.
+compiler.coverage=generates code coverage information
 compiler.debug=generates a movie that is suitable for debugging
 compiler.define=define a global AS3 conditional compilation definition, e.g. -define=CONFIG::debugging,true or -define+=CONFIG::debugging,true (to append to existing definitions in flex-config.xml) 
 compiler.defaults-css-url=defines the location of the default style sheet. Setting this option overrides the implicit use of the defaults.css style sheet in the framework.swc file.
Index: modules/compiler/src/java/flex2/compiler/Source.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/Source.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/Source.java	(working copy)
@@ -610,6 +610,18 @@
 			return null;
 		}
 	}
+	
+	public Source getCanonicalSource()
+	{
+	    if (delegate != null)
+	    {
+	        return delegate.getCanonicalSource();
+	    }
+	    else
+	    {
+	        return this;
+	    }
+	}
 
 	void clearSourceFragments()
 	{
Index: modules/compiler/src/java/flex2/compiler/CompilationUnit.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/CompilationUnit.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/CompilationUnit.java	(working copy)
@@ -160,6 +160,9 @@
 
 	public Styles styles;
 
+	// Set of coverage keys collected during this unit's compilation
+	public Set coverageKeys;
+	
 	/**
 	 * only MXML components set StylesContainer
 	 */
Index: modules/compiler/src/java/flex2/compiler/i18n/Compiler.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/i18n/Compiler.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/i18n/Compiler.java	(working copy)
@@ -52,6 +52,7 @@
     	configuration = compilerConfig;
         asc = new flex2.compiler.as3.Compiler(new flex2.compiler.as3.Configuration()
         {
+            public boolean coverage() { return false; }
             public boolean debug() { return false; }
             public boolean profile() { return false; }
             public boolean strict() { return true; }
Index: modules/compiler/src/java/flex2/compiler/as3/Configuration.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/as3/Configuration.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/as3/Configuration.java	(working copy)
@@ -22,6 +22,8 @@
 	 * Generate SWFs for debugging
 	 */
 	boolean debug();
+	
+	boolean coverage();
 
 	int dialect();
 	boolean adjustOpDebugLine();
Index: modules/compiler/src/java/flex2/compiler/as3/Compiler.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/as3/Compiler.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/as3/Compiler.java	(working copy)
@@ -673,6 +673,7 @@
 		LineNumberMap map = (LineNumberMap) context.getAttribute("LineNumberMap");
 		Emitter emitter = new BytecodeEmitter(cx, unit.getSource(),
 		                                      configuration != null && configuration.debug(),
+		                                      configuration != null && configuration.coverage(),
 		                                      (configuration != null && configuration.adjustOpDebugLine()) ? map : null);
 
 		cx.pushScope(node.frame);
@@ -701,6 +702,12 @@
 			}
 		}
 
+		// Plug the generated coverage keys into the top-level CompilationUnit that caused this one to be
+		// generated.
+		CompilationUnit originalUnit = unit.getSource().getCanonicalSource().getCompilationUnit();
+        originalUnit.coverageKeys = cx.getCoverageKeys();
+        cx.clearCoverageKeys();
+
 		cleanSlots((ObjectValue) unit.typeInfo, cx, unit.topLevelDefinitions);
 		unit.getContext().removeAttribute("cx");
 		cx.setHandler(null);
Index: modules/compiler/src/java/flex2/compiler/as3/BytecodeEmitter.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/as3/BytecodeEmitter.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/as3/BytecodeEmitter.java	(working copy)
@@ -14,8 +14,11 @@
 import flex2.compiler.Source;
 import flex2.compiler.util.LineNumberMap;
 import macromedia.asc.embedding.avmplus.ActionBlockEmitter;
+import macromedia.asc.embedding.avmplus.RuntimeConstants;
+import macromedia.asc.semantics.ObjectValue;
 import macromedia.asc.util.ByteList;
 import macromedia.asc.util.Context;
+import macromedia.asc.util.Namespaces;
 import macromedia.asc.util.StringPrintWriter;
 
 import java.io.File;
@@ -29,15 +32,16 @@
 {
 	public BytecodeEmitter(Context cx, Source source, boolean debug)
 	{
-		this(cx, source, debug, null);
+		this(cx, source, debug, false, null);
 	}
 
-	public BytecodeEmitter(Context cx, Source source, boolean debug, LineNumberMap map)
+	public BytecodeEmitter(Context cx, Source source, boolean debug, boolean coverage, LineNumberMap map)
 	{
 		super(cx, source != null ? source.getName() : null, new StringPrintWriter(), new StringPrintWriter(), false, false, false, debug);
 		this.map = map;
 		this.source = source;
 		this.cx = cx;
+        this.coverage = coverage; 
 
 		if (debug)
 		{
@@ -50,6 +54,8 @@
 	private Source source;
 	private String currentFileName;
 	private Context cx;
+	
+	private boolean coverage;
 
 	// C: not used when debug is false...
 	private Set lines;
@@ -73,13 +79,13 @@
 		}
 	}
 
-	protected void DebugFile(String name)
+	protected String DebugFile(String name)
 	{
 		currentFileName = name;
 
 		if (!source.isDebuggable())
 		{
-			return;
+			return name;
 		}
 
 		if (map != null)
@@ -120,7 +126,7 @@
 			}
 		}
 
-		super.DebugFile(name);
+		return super.DebugFile(name);
 	}
 
 	protected void DebugLine(ByteList code, int line)
@@ -154,6 +160,51 @@
 			super.DebugLine(code, newLine);
 		}
 	}
+	
+    public void RecordCoverage(String functionName, int linenum, String debugFileName)
+    {
+        // Short circuit if the line is beyond the end of the file.
+        if (linenum > cx.input.lnNum)
+        {
+            return;
+        }
+
+        if (!source.isDebuggable() || !coverage)
+        {
+            return;
+        }
+        
+        int newLine = calculateLineNumber(linenum);
+        if (newLine != -1)
+        {
+            final String COVERAGE = "coverage";
+            
+            String coverageKey = functionName + "@" + newLine;
+            
+            ObjectValue n = cx.publicNamespace();
+            Namespaces ns = cx.statics.internNamespaces.intern(n);
+            FindProperty(COVERAGE, ns, true, true, false);
+            PushString(coverageKey);
+            CallProperty(COVERAGE, ns, 1, true, false, false, false);
+            Pop();
+            
+            if (debugFileName != null)
+            {
+                String fileName;
+                int idx = debugFileName.indexOf(";;");
+                if (idx >= 0)
+                {
+                    fileName = debugFileName.substring(0, idx) + File.separator + debugFileName.substring(idx+2);
+                }
+                else
+                {
+                    fileName = debugFileName.replace(';', File.separatorChar);
+                }
+                coverageKey += ";" + fileName;
+            }
+            cx.statics.addCoverageKey(coverageKey);
+        }
+    }
 
 	private int calculateLineNumber(int line)
 	{
Index: modules/compiler/src/java/flex2/compiler/common/CompilerConfiguration.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/common/CompilerConfiguration.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/common/CompilerConfiguration.java	(working copy)
@@ -502,6 +502,34 @@
     }
 
     //
+    // 'compiler.coverage' option
+    //
+
+    private boolean coverage;
+
+    public boolean coverage()
+    {
+        return coverage;
+    }
+
+    public void cfgCoverage( ConfigurationValue cv, boolean coverage )
+    {
+        this.coverage = coverage;
+        this.generateDebugTags = this.generateDebugTags || coverage; 
+    }
+
+    public static ConfigurationInfo getCoverageInfo()
+    {
+        return new AdvancedConfigurationInfo()
+        {
+            public String[] getPrerequisites()
+            {
+                return new String[] { "debug" };
+            }
+        };
+    }
+
+    //
     // 'compiler.debug' option
     //
 
Index: modules/compiler/src/java/flex2/compiler/common/Configuration.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/common/Configuration.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/common/Configuration.java	(working copy)
@@ -384,6 +384,38 @@
     }
     
     //
+    // 'coverage-report' option
+    //
+    
+    private String coverageReportFileName = null;
+
+    public String getCoverageMetadataFileName()
+    {
+        return coverageReportFileName;
+    }
+    
+    public boolean generateCoverageMetadata()
+    {
+        return coverageReportFileName != null;
+    }
+
+    public void cfgCoverageMetadata( ConfigurationValue cv, String filename )
+    {
+        this.coverageReportFileName = getOutputPath(cv, filename);
+    }
+    
+    public static ConfigurationInfo getCoverageMetadataInfo()
+    {
+        return new ConfigurationInfo(new String[] {"filename"})
+        {
+            public boolean isAdvanced()
+            {
+                return true;
+            }
+        };
+    }
+
+    //
     // 'debug-password' option
     //
     
Index: modules/compiler/src/java/flex2/compiler/swc/API.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/swc/API.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/swc/API.java	(working copy)
@@ -211,6 +211,10 @@
             {
                 FileUtil.writeFile(configuration.getLinkReportFileName(), m.getLinkReport());
             }
+            if (configuration.generateCoverageMetadata() && configuration.getCoverageMetadataFileName() != null)
+            {
+                FileUtil.writeFile(configuration.getCoverageMetadataFileName(), m.getCoverageMetadata());
+            }
             if (configuration.generateRBList() && configuration.getRBListFileName() != null)
             {
                 FileUtil.writeFile(configuration.getRBListFileName(), m.getRBList());
Index: modules/compiler/src/java/flex2/compiler/swc/SwcMovie.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/swc/SwcMovie.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/swc/SwcMovie.java	(working copy)
@@ -15,6 +15,7 @@
 import flex2.linker.LinkerException;
 import flex2.linker.CULinkable;
 import flex2.linker.DependencyWalker;
+import flex2.linker.CoverageMetadataWriter;
 import flex2.linker.Configuration;
 import flex2.linker.FlexMovie;
 import flex2.compiler.CompilationUnit;
@@ -55,6 +56,7 @@
 	    includes = new HashSet(configuration.getIncludes());
         unresolved = new HashSet(configuration.getUnresolved());
         generateLinkReport = configuration.generateLinkReport();
+        generateCoverageMetadata = configuration.generateCoverageMetadata();
         generateRBList = configuration.generateRBList();
 
 	    resourceBundles = new TreeSet(configuration.getResourceBundles());
@@ -97,6 +99,10 @@
             {
             	linkReport = DependencyWalker.dump( state );
             }
+            if (generateCoverageMetadata)
+            {
+                coverageReport = CoverageMetadataWriter.dump( units );
+            }
             if (generateRBList)
             {
             	rbList = FlexMovie.dumpRBList(resourceBundles);
Index: modules/compiler/src/java/flex2/compiler/mxml/InterfaceCompiler.java
===================================================================
--- modules/compiler/src/java/flex2/compiler/mxml/InterfaceCompiler.java	(revision 744)
+++ modules/compiler/src/java/flex2/compiler/mxml/InterfaceCompiler.java	(working copy)
@@ -113,7 +113,8 @@
 		mimeTypes = new String[]{MimeMappings.MXML};
 		asc = new flex2.compiler.as3.Compiler(new flex2.compiler.as3.Configuration()
 		{
-			public boolean debug() { return false; }
+            public boolean coverage() { return false; }
+            public boolean debug() { return false; }
             public boolean profile() { return false; }
 			public boolean strict() { return ascConfiguration.strict(); }
 			public int dialect() { return ascConfiguration.dialect(); }
